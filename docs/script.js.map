{
  "version": 3,
  "sources": ["../node_modules/ger-morph-pw-gen/GermanMorphDict.js", "../node_modules/ger-morph-pw-gen/PasswordGenerator.js", "../src/script.ts"],
  "sourcesContent": ["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport var WordCategory;\n(function (WordCategory) {\n    WordCategory[\"VERB\"] = \"V\";\n    WordCategory[\"ADJECTIVE\"] = \"ADJ\";\n    WordCategory[\"ADVERB\"] = \"ADV\";\n    WordCategory[\"ARTICLE\"] = \"ART\";\n    WordCategory[\"CARDINAL\"] = \"CARD\";\n    WordCategory[\"CIRCUMPOSITION\"] = \"CIRCP\";\n    WordCategory[\"CONJUNCTION\"] = \"CONJ\";\n    WordCategory[\"DEMONSTRATIVE\"] = \"DEMO\";\n    WordCategory[\"INDEFINITE\"] = \"INDEF\";\n    WordCategory[\"INTERJECTION\"] = \"INTJ\";\n    WordCategory[\"ORDINAL\"] = \"ORD\";\n    WordCategory[\"NOUN\"] = \"NN\";\n    WordCategory[\"PROPER_NOUN\"] = \"NNP\";\n    WordCategory[\"POSSESSIVE\"] = \"POSS\";\n    WordCategory[\"POSTPOSITION\"] = \"POSTP\";\n    WordCategory[\"PRONOUN\"] = \"PRP\";\n    WordCategory[\"PREPOSITION\"] = \"PREP\";\n    WordCategory[\"PREPOSITION_ARTICLE\"] = \"PREPART\";\n    WordCategory[\"PRONOMINAL_ADVERB\"] = \"PROADV\";\n    WordCategory[\"PARTICLE\"] = \"PRTKL\";\n    WordCategory[\"RELATIVE\"] = \"REL\";\n    WordCategory[\"TRUNCATED\"] = \"TRUNC\";\n    WordCategory[\"VERB_PARTICLE\"] = \"VPART\";\n    WordCategory[\"WH_ADVERB\"] = \"WPADV\";\n    WordCategory[\"WH_PRONOUN\"] = \"WPRO\";\n    WordCategory[\"ZU\"] = \"ZU\";\n})(WordCategory || (WordCategory = {}));\nexport class GermanMorphDict {\n    /**\n     * Returns a promise that resolves when the dictionary is fully loaded\n     */\n    waitForReady() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.initialized;\n        });\n    }\n    constructor(dictData, progressCallback) {\n        this.dictionary = new Map();\n        this.totalEntries = 0;\n        this.initialized = (() => __awaiter(this, void 0, void 0, function* () {\n            if (dictData instanceof Response) {\n                yield this.loadDictFromResponse(dictData, progressCallback);\n            }\n            else {\n                this.loadDict(dictData, progressCallback);\n            }\n        }))();\n    }\n    loadDictFromResponse(response, progressCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!response.body) {\n                throw new Error('Response body is null');\n            }\n            const reader = response.body.getReader();\n            const decoder = new TextDecoder();\n            let buffer = '';\n            let totalBytes = +(response.headers.get('content-length') || 0);\n            let loadedBytes = 0;\n            while (true) {\n                const { done, value } = yield reader.read();\n                if (done) {\n                    // Process any remaining data in buffer\n                    this.processChunk(buffer, true);\n                    break;\n                }\n                loadedBytes += value.length;\n                buffer += decoder.decode(value, { stream: true });\n                // Find last newline character\n                const lastNewline = buffer.lastIndexOf('\\n');\n                if (lastNewline !== -1) {\n                    // Process complete lines\n                    const completeLines = buffer.slice(0, lastNewline);\n                    buffer = buffer.slice(lastNewline + 1);\n                    this.processChunk(completeLines, false);\n                }\n                // Report progress\n                if (progressCallback && totalBytes > 0) {\n                    progressCallback({\n                        totalLines: totalBytes, // Using bytes as proxy for lines\n                        processedLines: loadedBytes,\n                        percentage: (loadedBytes / totalBytes) * 100\n                    });\n                }\n            }\n            // Final progress update\n            if (progressCallback) {\n                progressCallback({\n                    totalLines: totalBytes,\n                    processedLines: totalBytes,\n                    percentage: 100\n                });\n            }\n        });\n    }\n    loadDict(dictData, progressCallback) {\n        this.processChunk(dictData, true);\n        if (progressCallback) {\n            progressCallback({\n                totalLines: dictData.split('\\n').length,\n                processedLines: dictData.split('\\n').length,\n                percentage: 100\n            });\n        }\n    }\n    processChunk(chunk, isLastChunk) {\n        const lines = chunk.split('\\n');\n        let currentWord = null;\n        let currentAnalyses = [];\n        for (const line of lines) {\n            const trimmedLine = line.trim();\n            if (!trimmedLine)\n                continue;\n            if (!trimmedLine.includes(\",\")) {\n                this.addCurrentWordToDictionary(currentWord, currentAnalyses);\n                currentWord = trimmedLine;\n                currentAnalyses = [];\n            }\n            else {\n                // This is an analysis line\n                const parts = trimmedLine.split(\" \");\n                if (parts.length < 2)\n                    continue; // Skip invalid lines\n                const analysisParts = parts[1].split(\",\");\n                const category = analysisParts[0];\n                const attributes = analysisParts.slice(1);\n                currentAnalyses.push({\n                    lemma: parts[0],\n                    category,\n                    attributes\n                });\n            }\n        }\n        // Add the last word if it exists and this is the last chunk\n        if (isLastChunk) {\n            this.addCurrentWordToDictionary(currentWord, currentAnalyses);\n        }\n    }\n    addCurrentWordToDictionary(currentWord, currentAnalyses) {\n        if (currentWord && currentAnalyses.length > 0) {\n            const entries = currentAnalyses.map(analysis => ({\n                word: currentWord,\n                analysis\n            }));\n            this.dictionary.set(currentWord, entries);\n            this.totalEntries += entries.length;\n        }\n    }\n    *filterWordsGenerator(regex, categories) {\n        let processedWords = 0;\n        for (const [word, entries] of this.dictionary) {\n            if (regex && !regex.test(word))\n                continue;\n            for (const entry of entries) {\n                if (!categories || categories.includes(entry.analysis.category)) {\n                    yield entry;\n                }\n            }\n        }\n    }\n    filterWords(regex, categories, progressCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.initialized;\n            const result = [];\n            const generator = this.filterWordsGenerator(regex, categories);\n            let processedEntries = 0;\n            for (const entry of generator) {\n                result.push(entry);\n                processedEntries++;\n                if (progressCallback && processedEntries % 1000 === 0) {\n                    progressCallback({\n                        processedEntries,\n                        totalEntries: this.totalEntries,\n                        percentage: (processedEntries / this.totalEntries) * 100\n                    });\n                }\n            }\n            // Final progress update\n            if (progressCallback) {\n                progressCallback({\n                    processedEntries: this.totalEntries,\n                    totalEntries: this.totalEntries,\n                    percentage: 100\n                });\n            }\n            return result;\n        });\n    }\n    combineFilters(regex, categories, progressCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.filterWords(regex, categories, progressCallback);\n        });\n    }\n    getDictionary() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.initialized;\n            const result = [];\n            for (const entries of this.dictionary.values()) {\n                result.push(...entries); // Include all analyses\n            }\n            return result;\n        });\n    }\n}\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { WordCategory } from './GermanMorphDict';\nexport var PasswordMode;\n(function (PasswordMode) {\n    PasswordMode[\"SIMPLE\"] = \"simple\";\n    PasswordMode[\"STRONG\"] = \"strong\";\n})(PasswordMode || (PasswordMode = {}));\nexport class PasswordGenerator {\n    constructor(dict) {\n        this.SPECIAL_CHARS = ['$', '!', '+'];\n        this.FILTERED_CHARS = new Set(['\u00C4', '\u00E4', '\u00D6', '\u00F6', '\u00DC', '\u00FC', '\u1E9E', '\u00DF', 'Y', 'y', 'Z', 'z']);\n        this.dict = dict;\n    }\n    getRandomItem(arr) {\n        return arr[Math.floor(Math.random() * arr.length)];\n    }\n    getRandomDigits(length) {\n        return Array.from({ length }, () => Math.floor(Math.random() * 10)).join('');\n    }\n    getFilteredWords() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Get nouns (nominative singular)\n            const nouns = yield this.dict.filterWords(undefined, [WordCategory.NOUN]);\n            const nomSingNouns = nouns.filter(entry => entry.analysis.attributes.includes('nom') &&\n                entry.analysis.attributes.includes('sing'));\n            // Get adjectives (nominative, singular, positive)\n            const adjectives = yield this.dict.filterWords(undefined, [WordCategory.ADJECTIVE]);\n            // Filter base adjectives by case and number\n            const baseFilteredAdj = adjectives.filter(entry => entry.analysis.attributes.includes('pos') &&\n                entry.analysis.attributes.includes('nom') &&\n                entry.analysis.attributes.includes('sing'));\n            // Group nouns by gender\n            const nounsByGender = {\n                masc: nomSingNouns.filter(n => n.analysis.attributes.includes('masc')),\n                fem: nomSingNouns.filter(n => n.analysis.attributes.includes('fem')),\n                neut: nomSingNouns.filter(n => n.analysis.attributes.includes('neut'))\n            };\n            // For adjectives, require strong declension for masculine and neuter\n            const adjByGender = {\n                masc: baseFilteredAdj.filter(a => a.analysis.attributes.includes('masc') &&\n                    a.analysis.attributes.includes('strong')),\n                fem: baseFilteredAdj.filter(a => a.analysis.attributes.includes('fem')),\n                neut: baseFilteredAdj.filter(a => a.analysis.attributes.includes('neut') &&\n                    a.analysis.attributes.includes('strong'))\n            };\n            return { adjByGender, nounsByGender };\n        });\n    }\n    filterStrongWords(words) {\n        return words.filter(entry => {\n            const word = entry.word;\n            // Filter out words containing filtered characters\n            for (const char of this.FILTERED_CHARS) {\n                if (word.includes(char))\n                    return false;\n            }\n            // Must contain at least one of S,s,I,i,T,t\n            return /[SsIiTt]/.test(word);\n        });\n    }\n    replaceSpecialChar(word) {\n        const charMap = {\n            'S': '$', 's': '$',\n            'I': '!', 'i': '!',\n            'T': '+', 't': '+'\n        };\n        const matches = word.match(/[SsIiTt]/g);\n        if (!matches)\n            return word;\n        const charToReplace = this.getRandomItem(matches);\n        return word.replace(charToReplace, charMap[charToReplace]);\n    }\n    generatePassword(mode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { adjByGender, nounsByGender } = yield this.getFilteredWords();\n            const gender = this.getRandomItem(['masc', 'fem', 'neut']);\n            let adjectives = adjByGender[gender];\n            let nouns = nounsByGender[gender];\n            if (mode === PasswordMode.STRONG) {\n                // Filter for words containing special characters and not containing filtered chars\n                adjectives = this.filterStrongWords(adjectives);\n                nouns = this.filterStrongWords(nouns);\n            }\n            if (!(adjectives === null || adjectives === void 0 ? void 0 : adjectives.length) || !(nouns === null || nouns === void 0 ? void 0 : nouns.length)) {\n                throw new Error(`No valid words found for gender: ${gender}`);\n            }\n            const adj = this.getRandomItem(adjectives);\n            const noun = this.getRandomItem(nouns);\n            let password = adj.word + noun.word;\n            if (mode === PasswordMode.STRONG) {\n                // Replace one special character and add random digits\n                password = this.replaceSpecialChar(password);\n                password += this.getRandomDigits(2);\n            }\n            return password;\n        });\n    }\n    generatePasswords(mode_1) {\n        return __awaiter(this, arguments, void 0, function* (mode, count = 10) {\n            const passwords = [];\n            const usedCombos = new Set();\n            // Try to generate up to count unique passwords\n            for (let i = 0; i < count * 3 && passwords.length < count; i++) {\n                try {\n                    const password = yield this.generatePassword(mode);\n                    if (!usedCombos.has(password)) {\n                        usedCombos.add(password);\n                        passwords.push(password);\n                    }\n                }\n                catch (error) {\n                    console.error('Error generating password:', error);\n                }\n            }\n            return passwords;\n        });\n    }\n}\n", "import { GermanMorphDict } from 'ger-morph-pw-gen/GermanMorphDict';\nimport { PasswordGenerator, PasswordMode } from 'ger-morph-pw-gen/PasswordGenerator';\n\n// Dictionary URLs\nconst DICT_URLS = {\n    light: 'https://raw.githubusercontent.com/KGT1/german-morph-filter/refs/heads/master/data/output/whitelist_dict.txt',\n    filtered: 'https://raw.githubusercontent.com/KGT1/german-morph-filter/refs/heads/master/data/output/DE_morph_dict_filtered.txt'\n};\n\n// UI Elements\nconst passwordDisplay = document.getElementById('password') as HTMLDivElement;\nconst modeToggle = document.getElementById('modeToggle') as HTMLButtonElement;\nconst regenerateBtn = document.getElementById('regenerateBtn') as HTMLButtonElement;\nconst lightDictBtn = document.getElementById('lightDict') as HTMLButtonElement;\nconst filteredDictBtn = document.getElementById('filteredDict') as HTMLButtonElement;\nconst fullDictBtn = document.getElementById('fullDict') as HTMLButtonElement;\nconst loadingElement = document.getElementById('loading') as HTMLDivElement;\nconst progressElement = document.getElementById('progress') as HTMLDivElement;\nconst errorElement = document.getElementById('error') as HTMLDivElement;\n\n// State\nlet currentMode = PasswordMode.STRONG;\nlet currentGenerator: PasswordGenerator | null = null;\n\n// UI Update Functions\nfunction updateModeDisplay(): void {\n    const currentModeDisplay = document.getElementById('currentMode') as HTMLSpanElement;\n    currentModeDisplay.textContent = `(Aktuell: ${currentMode === PasswordMode.SIMPLE ? 'Einfacher Modus' : 'Sicherer Modus'})`;\n    modeToggle.textContent = currentMode === PasswordMode.SIMPLE ? 'Einfacher Modus' : 'Sicherer Modus';\n}\n\nfunction updateDictDisplay(type: 'light' | 'filtered'): void {\n    const currentDictDisplay = document.getElementById('currentDict') as HTMLSpanElement;\n    currentDictDisplay.textContent = `(Aktuell: ${type === 'light' ? 'Leicht' : 'Normal'})`;\n}\n\n// UI Functions\nasync function updatePassword(): Promise<void> {\n    if (!currentGenerator) return;\n\n    try {\n        const password = await currentGenerator.generatePassword(currentMode);\n        passwordDisplay.textContent = password;\n    } catch (error) {\n        showError((error as Error).message);\n    }\n}\n\nfunction showError(message: string): void {\n    errorElement.textContent = message;\n    errorElement.classList.remove('hidden');\n    setTimeout(() => {\n        errorElement.classList.add('hidden');\n    }, 5000);\n}\n\nfunction updateLoadingProgress(progress: { percentage: number }): void {\n    progressElement.style.width = `${progress.percentage}%`;\n}\n\nfunction showLoading(): void {\n    loadingElement.classList.remove('hidden');\n}\n\nfunction hideLoading(): void {\n    loadingElement.classList.add('hidden');\n}\n\nasync function loadDictionary(url: string): Promise<void> {\n    showLoading();\n    try {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error('Fehler beim Laden des W\u00F6rterbuchs');\n        }\n\n        const dict = new GermanMorphDict(response, updateLoadingProgress);\n        await dict.waitForReady();\n        currentGenerator = new PasswordGenerator(dict);\n        await updatePassword();\n    } catch (error) {\n        showError((error as Error).message);\n    } finally {\n        hideLoading();\n    }\n}\n\n// Event Listeners\nmodeToggle.addEventListener('click', () => {\n    currentMode = currentMode === PasswordMode.SIMPLE ? PasswordMode.STRONG : PasswordMode.SIMPLE;\n    updateModeDisplay();\n    updatePassword();\n});\n\nregenerateBtn.addEventListener('click', updatePassword);\n\nlightDictBtn.addEventListener('click', () => {\n    loadDictionary(DICT_URLS.light);\n    [lightDictBtn, filteredDictBtn].forEach(btn => btn.classList.remove('active'));\n    lightDictBtn.classList.add('active');\n    updateDictDisplay('light');\n});\n\nfilteredDictBtn.addEventListener('click', () => {\n    loadDictionary(DICT_URLS.filtered);\n    [lightDictBtn, filteredDictBtn].forEach(btn => btn.classList.remove('active'));\n    filteredDictBtn.classList.add('active');\n    updateDictDisplay('filtered');\n});\n\n// Initial load\ndocument.addEventListener('DOMContentLoaded', () => {\n    loadDictionary(DICT_URLS.light); // Start with light dictionary\n    lightDictBtn.classList.add('active');\n    updateModeDisplay();\n    updateDictDisplay('light');\n});\n"],
  "mappings": "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",
  "names": ["WordCategory", "__awaiter", "PasswordMode"]
}
