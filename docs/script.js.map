{
  "version": 3,
  "sources": ["../node_modules/ger-morph-pw-gen/GermanMorphDict.ts", "../node_modules/ger-morph-pw-gen/PasswordGenerator.ts", "../src/script.ts"],
  "sourcesContent": ["/**\n * Enumeration of possible word categories in German morphology\n */\nexport enum WordCategory {\n    VERB = \"V\",\n    ADJECTIVE = \"ADJ\",\n    ADVERB = \"ADV\",\n    ARTICLE = \"ART\",\n    CARDINAL = \"CARD\",\n    CIRCUMPOSITION = \"CIRCP\",\n    CONJUNCTION = \"CONJ\",\n    DEMONSTRATIVE = \"DEMO\",\n    INDEFINITE = \"INDEF\",\n    INTERJECTION = \"INTJ\",\n    ORDINAL = \"ORD\",\n    NOUN = \"NN\",\n    PROPER_NOUN = \"NNP\",\n    POSSESSIVE = \"POSS\",\n    POSTPOSITION = \"POSTP\",\n    PRONOUN = \"PRP\",\n    PREPOSITION = \"PREP\",\n    PREPOSITION_ARTICLE = \"PREPART\",\n    PRONOMINAL_ADVERB = \"PROADV\",\n    PARTICLE = \"PRTKL\",\n    RELATIVE = \"REL\",\n    TRUNCATED = \"TRUNC\",\n    VERB_PARTICLE = \"VPART\",\n    WH_ADVERB = \"WPADV\",\n    WH_PRONOUN = \"WPRO\",\n    ZU = \"ZU\",\n}\n\n/**\n * Represents the morphological analysis of a word\n */\nexport interface MorphAnalysis {\n    /** Base form of the word */\n    readonly lemma: string;\n    /** Grammatical category of the word */\n    readonly category: WordCategory;\n    /** Array of morphological attributes (e.g., case, number, gender) */\n    readonly attributes: readonly string[];\n}\n\n/**\n * Represents a word entry in the dictionary with its morphological analysis\n */\nexport interface WordEntry {\n    /** The word form */\n    readonly word: string;\n    /** Morphological analysis of the word */\n    readonly analysis: MorphAnalysis;\n}\n\n/**\n * Progress information during dictionary loading\n */\nexport interface LoadProgress {\n    /** Total number of lines to process */\n    readonly totalLines: number;\n    /** Number of lines processed so far */\n    readonly processedLines: number;\n    /** Percentage of completion (0-100) */\n    readonly percentage: number;\n}\n\n/**\n * Progress information during word filtering\n */\nexport interface FilterProgress {\n    /** Number of entries processed so far */\n    readonly processedEntries: number;\n    /** Total number of entries to process */\n    readonly totalEntries: number;\n    /** Percentage of completion (0-100) */\n    readonly percentage: number;\n}\n\n/**\n * German morphological dictionary that provides word analysis and filtering capabilities\n */\nexport class GermanMorphDict {\n    private readonly dictionary: Map<string, readonly WordEntry[]> = new Map();\n    private totalEntries: number = 0;\n    private readonly initialized: Promise<void>;\n\n    /**\n     * Creates a new German morphological dictionary instance\n     * @param dictData - Dictionary data as string or Response object\n     * @param progressCallback - Optional callback for loading progress updates\n     */\n    constructor(\n        dictData: string | Response,\n        progressCallback?: (progress: LoadProgress) => void\n    ) {\n        this.initialized = (async () => {\n            if (dictData instanceof Response) {\n                await this.loadDictFromResponse(dictData, progressCallback);\n            } else {\n                this.loadDict(dictData, progressCallback);\n            }\n        })();\n    }\n\n    /**\n     * Waits for the dictionary to be fully loaded\n     * @returns Promise that resolves when dictionary is ready\n     */\n    public async waitForReady(): Promise<void> {\n        await this.initialized;\n    }\n\n    /**\n     * Loads dictionary data from a Response object (e.g., fetch response)\n     * @param response - Response object containing dictionary data\n     * @param progressCallback - Optional callback for loading progress updates\n     * @throws Error if response body is null or data is invalid\n     */\n    private async loadDictFromResponse(\n        response: Response,\n        progressCallback?: (progress: LoadProgress) => void\n    ): Promise<void> {\n        if (!response.body) {\n            throw new Error('Response body is null');\n        }\n\n        const reader = response.body.getReader();\n        const decoder = new TextDecoder();\n        let buffer = '';\n        const totalBytes = Number(response.headers.get('content-length') || 0);\n        let loadedBytes = 0;\n\n        try {\n            while (true) {\n                const {done, value} = await reader.read();\n                \n                if (done) {\n                    this.processChunk(buffer, true);\n                    break;\n                }\n\n                loadedBytes += value.length;\n                buffer += decoder.decode(value, {stream: true});\n\n                const lastNewline = buffer.lastIndexOf('\\n');\n                if (lastNewline !== -1) {\n                    const completeLines = buffer.slice(0, lastNewline);\n                    buffer = buffer.slice(lastNewline + 1);\n                    this.processChunk(completeLines, false);\n                }\n\n                if (progressCallback && totalBytes > 0) {\n                    progressCallback({\n                        totalLines: totalBytes,\n                        processedLines: loadedBytes,\n                        percentage: (loadedBytes / totalBytes) * 100\n                    });\n                }\n            }\n\n            if (progressCallback) {\n                progressCallback({\n                    totalLines: totalBytes,\n                    processedLines: totalBytes,\n                    percentage: 100\n                });\n            }\n        } catch (error) {\n            throw new Error(`Failed to load dictionary: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    }\n\n    /**\n     * Loads dictionary data from a string\n     * @param dictData - String containing dictionary data\n     * @param progressCallback - Optional callback for loading progress updates\n     */\n    private loadDict(\n        dictData: string,\n        progressCallback?: (progress: LoadProgress) => void\n    ): void {\n        this.processChunk(dictData, true);\n        \n        const totalLines = dictData.split('\\n').length;\n        if (progressCallback) {\n            progressCallback({\n                totalLines,\n                processedLines: totalLines,\n                percentage: 100\n            });\n        }\n    }\n\n    /**\n     * Processes a chunk of dictionary data\n     * @param chunk - String chunk of dictionary data\n     * @param isLastChunk - Whether this is the final chunk\n     */\n    private processChunk(chunk: string, isLastChunk: boolean): void {\n        const lines = chunk.split('\\n');\n        let currentWord: string | null = null;\n        let currentAnalyses: MorphAnalysis[] = [];\n\n        for (const line of lines) {\n            const trimmedLine = line.trim();\n            if (!trimmedLine) continue;\n\n            if (!trimmedLine.includes(\",\")) {\n                this.addCurrentWordToDictionary(currentWord, currentAnalyses);\n                currentWord = trimmedLine;\n                currentAnalyses = [];\n            } else {\n                const parts = trimmedLine.split(\" \");\n                if (parts.length < 2) continue;\n\n                const lemma = parts[0];\n                if (!lemma) continue;\n\n                const analysis = parts[1];\n                if (!analysis) continue;\n\n                const analysisParts = analysis.split(\",\");\n                if (!analysisParts.length) continue;\n\n                const category = analysisParts[0];\n                if (!Object.values(WordCategory).includes(category as WordCategory)) continue;\n\n                currentAnalyses.push({\n                    lemma,\n                    category: category as WordCategory,\n                    attributes: analysisParts.slice(1)\n                });\n            }\n        }\n\n        if (isLastChunk) {\n            this.addCurrentWordToDictionary(currentWord, currentAnalyses);\n        }\n    }\n\n    /**\n     * Adds a word and its analyses to the dictionary\n     * @param currentWord - Word to add\n     * @param currentAnalyses - Array of morphological analyses for the word\n     */\n    private addCurrentWordToDictionary(\n        currentWord: string | null,\n        currentAnalyses: readonly MorphAnalysis[]\n    ): void {\n        if (currentWord && currentAnalyses.length > 0) {\n            const entries = currentAnalyses.map(analysis => ({\n                word: currentWord,\n                analysis\n            }));\n            this.dictionary.set(currentWord, entries);\n            this.totalEntries += entries.length;\n        }\n    }\n\n    /**\n     * Generator function that yields filtered word entries\n     * @param regex - Optional regex pattern to filter words\n     * @param categories - Optional array of word categories to filter by\n     * @yields WordEntry objects matching the filter criteria\n     */\n    *filterWordsGenerator(\n        regex?: RegExp,\n        categories?: readonly WordCategory[]\n    ): Generator<WordEntry, void, unknown> {\n        for (const [word, entries] of this.dictionary) {\n            if (regex && !regex.test(word)) continue;\n            \n            for (const entry of entries) {\n                if (!categories || categories.includes(entry.analysis.category)) {\n                    yield entry;\n                }\n            }\n        }\n    }\n\n    /**\n     * Filters dictionary entries based on regex pattern and/or word categories\n     * @param regex - Optional regex pattern to filter words\n     * @param categories - Optional array of word categories to filter by\n     * @param progressCallback - Optional callback for filtering progress updates\n     * @returns Promise resolving to array of filtered word entries\n     */\n    async filterWords(\n        regex?: RegExp,\n        categories?: readonly WordCategory[],\n        progressCallback?: (progress: FilterProgress) => void\n    ): Promise<readonly WordEntry[]> {\n        await this.initialized;\n        const result: WordEntry[] = [];\n        const generator = this.filterWordsGenerator(regex, categories);\n        let processedEntries = 0;\n\n        for (const entry of generator) {\n            result.push(entry);\n            processedEntries++;\n\n            if (progressCallback && processedEntries % 1000 === 0) {\n                progressCallback({\n                    processedEntries,\n                    totalEntries: this.totalEntries,\n                    percentage: (processedEntries / this.totalEntries) * 100\n                });\n            }\n        }\n\n        if (progressCallback) {\n            progressCallback({\n                processedEntries: this.totalEntries,\n                totalEntries: this.totalEntries,\n                percentage: 100\n            });\n        }\n\n        return result;\n    }\n\n    /**\n     * Alias for filterWords method\n     * @deprecated Use filterWords instead\n     */\n    async combineFilters(\n        regex?: RegExp,\n        categories?: readonly WordCategory[],\n        progressCallback?: (progress: FilterProgress) => void\n    ): Promise<readonly WordEntry[]> {\n        return this.filterWords(regex, categories, progressCallback);\n    }\n\n    /**\n     * Gets all entries in the dictionary\n     * @returns Promise resolving to array of all word entries\n     */\n    async getDictionary(): Promise<readonly WordEntry[]> {\n        await this.initialized;\n        const result: WordEntry[] = [];\n        for (const entries of this.dictionary.values()) {\n            result.push(...entries);\n        }\n        return result;\n    }\n}\n", "import { GermanMorphDict, WordCategory, WordEntry } from './GermanMorphDict';\n\n/**\n * Password generation modes that determine the complexity and format of generated passwords\n */\nexport enum PasswordMode {\n    /** Simple mode generates passwords without special characters or numbers */\n    SIMPLE = \"simple\",\n    /** Strong mode includes special character substitutions and numbers */\n    STRONG = \"strong\"\n}\n\n/**\n * Configuration for special character substitutions in strong password mode\n */\nconst SPECIAL_CHAR_MAP: Readonly<Record<string, string>> = {\n    'S': '$', 's': '$',\n    'I': '!', 'i': '!',\n    'T': '+', 't': '+'\n} as const;\n\n/**\n * Characters that should be filtered out from strong passwords\n */\nconst STRONG_MODE_FILTERED_CHARS: ReadonlySet<string> = new Set([\n    '\u00C4', '\u00E4', '\u00D6', '\u00F6', '\u00DC', '\u00FC', '\u1E9E', '\u00DF', 'Y', 'y', 'Z', 'z'\n]);\n\n/**\n * Interface for word groups organized by grammatical gender\n */\ninterface GenderedWords {\n    adjByGender: Record<string, WordEntry[]>;\n    nounsByGender: Record<string, WordEntry[]>;\n}\n\n/**\n * Generates secure passwords using German morphological word combinations\n */\nexport class PasswordGenerator {\n    private readonly dict: GermanMorphDict;\n\n    /**\n     * Creates a new password generator instance\n     * @param dict - German morphological dictionary instance\n     */\n    constructor(dict: GermanMorphDict) {\n        this.dict = dict;\n    }\n\n    /**\n     * Gets a random item from an array\n     * @param arr - Array to select from\n     * @returns Random item from the array\n     * @throws Error if array is empty\n     */\n    private getRandomItem<T>(arr: readonly T[]): T {\n        if (!arr.length) {\n            throw new Error('Cannot get random item from empty array');\n        }\n        const index = Math.floor(Math.random() * arr.length);\n        // This assertion is safe because we checked arr.length > 0\n        return arr[index]!;\n    }\n\n    /**\n     * Generates a string of random digits\n     * @param length - Number of digits to generate\n     * @returns String of random digits\n     */\n    private getRandomDigits(length: number): string {\n        return Array.from(\n            { length }, \n            () => Math.floor(Math.random() * 10)\n        ).join('');\n    }\n\n    /**\n     * Retrieves and filters words from the dictionary based on grammatical criteria\n     * @returns Promise resolving to filtered adjectives and nouns grouped by gender\n     */\n    private async getFilteredWords(): Promise<GenderedWords> {\n        // Get nouns (nominative singular)\n        const nouns = await this.dict.filterWords(undefined, [WordCategory.NOUN]);\n        const nomSingNouns = nouns.filter(entry =>\n            entry.analysis.attributes.includes('nom') &&\n            entry.analysis.attributes.includes('sing')\n        );\n\n        // Get adjectives (nominative, singular, positive)\n        const adjectives = await this.dict.filterWords(undefined, [WordCategory.ADJECTIVE]);\n        const baseFilteredAdj = adjectives.filter(entry =>\n            entry.analysis.attributes.includes('pos') &&\n            entry.analysis.attributes.includes('nom') &&\n            entry.analysis.attributes.includes('sing')\n        );\n\n        // Group nouns by gender\n        const nounsByGender: Record<string, WordEntry[]> = {\n            masc: nomSingNouns.filter(n => n.analysis.attributes.includes('masc')),\n            fem: nomSingNouns.filter(n => n.analysis.attributes.includes('fem')),\n            neut: nomSingNouns.filter(n => n.analysis.attributes.includes('neut'))\n        };\n\n        // For adjectives, require strong declension for masculine and neuter\n        const adjByGender: Record<string, WordEntry[]> = {\n            masc: baseFilteredAdj.filter(a => \n                a.analysis.attributes.includes('masc') &&\n                a.analysis.attributes.includes('strong')\n            ),\n            fem: baseFilteredAdj.filter(a => a.analysis.attributes.includes('fem')),\n            neut: baseFilteredAdj.filter(a => \n                a.analysis.attributes.includes('neut') &&\n                a.analysis.attributes.includes('strong')\n            )\n        };\n\n        return { adjByGender, nounsByGender };\n    }\n\n    /**\n     * Filters words to ensure they meet strong password criteria\n     * @param words - Array of word entries to filter\n     * @returns Filtered array of word entries suitable for strong passwords\n     */\n    private filterStrongWords(words: ReadonlyArray<WordEntry>): WordEntry[] {\n        return words.filter(entry => {\n            const word = entry.word;\n            \n            // Filter out words with special characters in strong mode\n            if ([...STRONG_MODE_FILTERED_CHARS].some(char => word.includes(char))) {\n                return false;\n            }\n\n            // Must contain at least one character that can be replaced with a special character\n            return Object.keys(SPECIAL_CHAR_MAP).some(char => word.includes(char));\n        });\n    }\n\n    /**\n     * Gets filtered words based on the password mode\n     * @param words - Array of word entries to filter\n     * @param mode - Password generation mode\n     * @returns Filtered array of word entries\n     */\n    private getWordsByMode(words: ReadonlyArray<WordEntry>, mode: PasswordMode): WordEntry[] {\n        if (mode === PasswordMode.STRONG) {\n            return this.filterStrongWords(words);\n        }\n        return [...words];\n    }\n\n    /**\n     * Replaces a random eligible character with its special character equivalent\n     * @param word - Word to process\n     * @returns Word with one special character substitution\n     */\n    private replaceSpecialChar(word: string): string {\n        const eligibleChars = word.match(/[SsIiTt]/g);\n        if (!eligibleChars) return word;\n        \n        const charToReplace = this.getRandomItem(eligibleChars);\n        const replacement = SPECIAL_CHAR_MAP[charToReplace as keyof typeof SPECIAL_CHAR_MAP];\n        \n        if (!replacement) return word;\n        return word.replace(charToReplace, replacement);\n    }\n\n    /**\n     * Generates a single password\n     * @param mode - Password generation mode\n     * @returns Promise resolving to generated password\n     * @throws Error if no valid words are found or if word filtering fails\n     */\n    async generatePassword(mode: PasswordMode): Promise<string> {\n        const { adjByGender, nounsByGender } = await this.getFilteredWords();\n        const gender = this.getRandomItem(['masc', 'fem', 'neut']);\n        \n        let adjectives = adjByGender[gender];\n        let nouns = nounsByGender[gender];\n\n        if (!adjectives?.length || !nouns?.length) {\n            throw new Error(`No valid words found for gender: ${gender}`);\n        }\n\n        adjectives = this.getWordsByMode(adjectives, mode);\n        nouns = this.getWordsByMode(nouns, mode);\n\n        if (!adjectives.length || !nouns.length) {\n            throw new Error(`No valid words found for gender: ${gender} in ${mode} mode`);\n        }\n\n        const adj = this.getRandomItem(adjectives);\n        const noun = this.getRandomItem(nouns);\n        let password = adj.word + noun.word;\n\n        if (mode === PasswordMode.STRONG) {\n            password = this.replaceSpecialChar(password);\n            password += this.getRandomDigits(2);\n        }\n\n        return password;\n    }\n\n    /**\n     * Generates multiple unique passwords\n     * @param mode - Password generation mode\n     * @param count - Number of passwords to generate (default: 10)\n     * @returns Promise resolving to array of unique passwords\n     */\n    async generatePasswords(mode: PasswordMode, count: number = 10): Promise<string[]> {\n        if (count < 1) {\n            throw new Error('Password count must be greater than 0');\n        }\n\n        const passwords: string[] = [];\n        const usedCombos = new Set<string>();\n        const maxAttempts = count * 3;\n\n        for (let attempts = 0; attempts < maxAttempts && passwords.length < count; attempts++) {\n            try {\n                const password = await this.generatePassword(mode);\n                if (!usedCombos.has(password)) {\n                    usedCombos.add(password);\n                    passwords.push(password);\n                }\n            } catch (error) {\n                console.error('Error generating password:', error instanceof Error ? error.message : 'Unknown error');\n            }\n        }\n\n        if (!passwords.length) {\n            throw new Error('Failed to generate any valid passwords');\n        }\n\n        return passwords;\n    }\n}\n", "import { GermanMorphDict } from 'ger-morph-pw-gen/GermanMorphDict';\nimport { PasswordGenerator, PasswordMode } from 'ger-morph-pw-gen/PasswordGenerator';\n\n// Dictionary URLs\nconst DICT_URLS = {\n    light: 'https://raw.githubusercontent.com/KGT1/german-morph-filter/refs/heads/master/data/output/whitelist_dict.txt',\n    filtered: 'https://raw.githubusercontent.com/KGT1/german-morph-filter/refs/heads/master/data/output/DE_morph_dict_filtered.txt'\n};\n\n// UI Elements\nconst themeToggle = document.getElementById('themeToggle') as HTMLButtonElement;\nconst passwordDisplay = document.getElementById('password') as HTMLDivElement;\nconst modeToggle = document.getElementById('modeToggle') as HTMLButtonElement;\nconst regenerateBtn = document.getElementById('regenerateBtn') as HTMLButtonElement;\nconst lightDictBtn = document.getElementById('lightDict') as HTMLButtonElement;\nconst filteredDictBtn = document.getElementById('filteredDict') as HTMLButtonElement;\nconst loadingElement = document.getElementById('loading') as HTMLDivElement;\nconst progressElement = document.getElementById('progress') as HTMLDivElement;\nconst errorElement = document.getElementById('error') as HTMLDivElement;\n\n// State\nlet currentMode = PasswordMode.STRONG;\nlet currentGenerator: PasswordGenerator | null = null;\n// Theme state management\nlet isDarkMode = localStorage.getItem('theme') === 'dark' || \n    (localStorage.getItem('theme') === null && window.matchMedia('(prefers-color-scheme: dark)').matches);\n\n// Theme Functions\nfunction toggleTheme(): void {\n    isDarkMode = !isDarkMode;\n    document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light');\n    localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');\n    themeToggle.innerHTML = isDarkMode ? '\u2600\uFE0F Tagmodus' : '\uD83C\uDF19 Nachtmodus';\n}\n\n// Initialize theme\nfunction initializeTheme(): void {\n    document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light');\n    themeToggle.innerHTML = isDarkMode ? '\u2600\uFE0F Tagmodus' : '\uD83C\uDF19 Nachtmodus';\n\n    // Listen for system theme changes\n    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {\n        if (localStorage.getItem('theme') === null) {  // Only auto-switch if user hasn't manually set a preference\n            isDarkMode = e.matches;\n            document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light');\n            themeToggle.innerHTML = isDarkMode ? '\u2600\uFE0F Tagmodus' : '\uD83C\uDF19 Nachtmodus';\n        }\n    });\n}\n\n// UI Update Functions\nfunction updateModeDisplay(): void {\n    const currentModeDisplay = document.getElementById('currentMode') as HTMLSpanElement;\n    currentModeDisplay.textContent = `(Aktuell: ${currentMode === PasswordMode.SIMPLE ? 'Einfacher Modus' : 'Sicherer Modus'})`;\n    modeToggle.textContent = currentMode === PasswordMode.SIMPLE ? 'Einfacher Modus' : 'Sicherer Modus';\n}\n\nfunction updateDictDisplay(type: 'light' | 'filtered'): void {\n    const currentDictDisplay = document.getElementById('currentDict') as HTMLSpanElement;\n    currentDictDisplay.textContent = `(Aktuell: ${type === 'light' ? 'Leicht' : 'Normal'})`;\n}\n\n// UI Functions\nasync function updatePassword(): Promise<void> {\n    if (!currentGenerator) return;\n\n    try {\n        const password = await currentGenerator.generatePassword(currentMode);\n        passwordDisplay.textContent = password;\n    } catch (error) {\n        showError((error as Error).message);\n    }\n}\n\nfunction showError(message: string): void {\n    errorElement.textContent = message;\n    errorElement.classList.remove('hidden');\n    setTimeout(() => {\n        errorElement.classList.add('hidden');\n    }, 5000);\n}\n\nfunction updateLoadingProgress(progress: { percentage: number }): void {\n    progressElement.style.width = `${progress.percentage}%`;\n}\n\nfunction showLoading(): void {\n    loadingElement.classList.remove('hidden');\n}\n\nfunction hideLoading(): void {\n    loadingElement.classList.add('hidden');\n}\n\nasync function loadDictionary(url: string): Promise<void> {\n    showLoading();\n    try {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error('Fehler beim Laden des W\u00F6rterbuchs');\n        }\n\n        const dict = new GermanMorphDict(response, updateLoadingProgress);\n        await dict.waitForReady();\n        currentGenerator = new PasswordGenerator(dict);\n        await updatePassword();\n    } catch (error) {\n        showError((error as Error).message);\n    } finally {\n        hideLoading();\n    }\n}\n\n// Event Listeners\nmodeToggle.addEventListener('click', () => {\n    currentMode = currentMode === PasswordMode.SIMPLE ? PasswordMode.STRONG : PasswordMode.SIMPLE;\n    updateModeDisplay();\n    updatePassword();\n});\n\nregenerateBtn.addEventListener('click', updatePassword);\n\nlightDictBtn.addEventListener('click', () => {\n    loadDictionary(DICT_URLS.light);\n    [lightDictBtn, filteredDictBtn].forEach(btn => btn.classList.remove('active'));\n    lightDictBtn.classList.add('active');\n    updateDictDisplay('light');\n});\n\nfilteredDictBtn.addEventListener('click', () => {\n    loadDictionary(DICT_URLS.filtered);\n    [lightDictBtn, filteredDictBtn].forEach(btn => btn.classList.remove('active'));\n    filteredDictBtn.classList.add('active');\n    updateDictDisplay('filtered');\n});\n\n// Initial load\ndocument.addEventListener('DOMContentLoaded', () => {\n    loadDictionary(DICT_URLS.light); // Start with light dictionary\n    lightDictBtn.classList.add('active');\n    updateModeDisplay();\n    updateDictDisplay('light');\n    initializeTheme();\n});\n\n// Theme toggle event listener\nthemeToggle.addEventListener('click', toggleTheme);\n"],
  "mappings": "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",
  "names": ["WordCategory", "PasswordMode"]
}
